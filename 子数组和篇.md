# 子数组和
---

## 找到和=X或取余X的子数组


使用前缀和来求解这种问题，假设给定数组A = {a1, a2, a3, ... , aN}，求其前缀和，$S = \{a_1, a_1+a_2, a_1+a_2+a_3,\dots \}$，则可以在常数时间内求解 $Sum A[i:j]$。即 <br/>
$$
\text{if } i = 0 \text{ then } \sum A[i:j] = S[j] - 0 \\
\text{else} \sum A[i:j] = S[j] - S[i-1]
$$

### 560. [和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/) ```medium```
<img src="img/560.png" width="">

**分析**<br/><br/>
利用前缀和公式我们可以得到 $S[i-1] = S[j] - \sum A[i;j]$ 或$S[j] = \sum A[i;j] - 0$ ，因此，我们遍历前缀和数组，只需要检查前面出现是否出现过 S-k或S直接等于K即可。

**算法如下**<br/>
```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        S = 0
        prevs = {0:1}
        ans = 0

        for n in nums:
            S += n
            ans += prevs.get(S-k, 0)
            prevs[S] = prevs.get(S, 0) + 1
        return ans
```

### 930. [和相同的二元子数组](https://leetcode-cn.com/problems/binary-subarrays-with-sum/) ```medium```
<img src="img/930.png" width=""> 

**分析**<br/><br/>
这道题和前面一样解法

**算法如下**<br/>
```python
class Solution:
    def numSubarraysWithSum(self, A: List[int], S: int) -> int:
        s, ans, prevs = 0, 0, {0:1}
        for n in A:
            s += n 
            ans += prevs.get(s-S, 0)
            prevs[s] = prevs.get(s, 0) + 1
        return ans
```


### 523. [连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/) ```medium```
<img src="img/523.png" width=""> 

**分析**<br/><br/>
这道题是前面一题的变体，要求总和为K的倍数，实际上就是模K为0，可以通过不断取余来实现。
$$
   \sum A[i:j] = S[j] - S[i-1] \\ 
   (S[j] - S[i-1]) \text{ mod } K = 0 \rightarrow S[i-1] \text{ mod } K = S[j]
$$
另外当i为0时，$S[j] \text{ mod } K = 0$

即我们现在保存的前缀和为对K取余的结果。由于题目要求长度至少为2，且并没有要求判断个数，而只是判断存在性。因此只需要用一个hash表保存之前第一次出现过的前缀和的index即可。

**算法如下**<br/>
```python
class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        S = 0
        prevs = {0:-1}
        for idx, n in enumerate(nums):
            S += n 
            if k != 0: S = S % k 
            if S in prevs:
                if prevs[S] != idx-1:
                    return True 
            else:
                prevs[S] = idx 
        return False
```

### 974. [和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/) ```medium```
<img src="img/974.png" width=""> 

**分析**<br/><br/>
这道题是前面一题的变体，要求总和为K的倍数的数组个数，和前面一样的方法，由于这里不需要验证必须大于2了，和第一题一样即可。

**算法如下**<br/>
```python
class Solution:
    def subarraysDivByK(self, A: List[int], K: int) -> int:
        S, prevs, ans = 0, {0:1}, 0
        for n in A:
            S = (S+n) % K 
            count = prevs.get(S, 0)
            ans += count 
            prevs[S] = count + 1
        return ans
```


## 子数组最大和（最大子序和）

最大子序（子数组）问题可以分为如下几种：
1. 任意长度的最大子序和：Kadane算法及其变体解决，该算法可以以 $O(N)$ 的时间复杂度解决在一个数组 $A[i:j]$ 内的最大子序和问题。其思想为维持一个数组记录到第i个元素为止，最大的子序和（该子数组一定以 $A[i]$ 为结尾）。

    $S[i] = max(S[i-1] + A[i], A[i])$ 或 $S[i] = max(S[i-1], 0) + A[i]$

2. 规定长度的最大子序和：前缀和+DP。前缀和可以常识时间获得给定序列的和。
3. 限制长度的最大子序和:


### 53. [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/) ```easy```
<img src="img/53.png" width=""> 


**分析**<br/><br/>
直接使用Kadane算法求解

**算法如下**<br/>
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        s = -1
        ans = nums[0]
        for n in nums:
            s = max(s, 0) + n
            ans = max(ans, s)
        return ans
```


### 1031. [两个非重叠子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-of-two-non-overlapping-subarrays/) ```medium```
<img src="img/1031.png" width=""> 


**分析**<br/><br/>
这道题目的难点是要同时求两个非重叠的子数组，而且规定了子数组的长度。首先需要求得 $A[0:j]$ 内，长度为 $L$ 的最大子序和（不一定要包括j），使用前缀和加DP解决。通过前缀和可以常数时间内获得 $\sum A[j-L, j]$ ，然后利用DP一直记录即可。在获取 $A[0:j]$ 内，长度为 $L$ 的最大子序和后，首先假设 $L$ 在前，$M$ 在后，则遍历所有的长度为 $L$ 的最大子序和以及长度为 $M$ 的子数组，即可获得全局最优解。然后反过来即可。

假设 $S$ 为前缀和数组，$X$ 为长度为 $L$ 的最大子序和，$y$ 为长度为 $M$ 的最大子序和。则
$$

ans = max(ans, X[i-M] + S[i] - S[i-M], Y[i-L] + S[i] - S[i-L]) \text{ for } i >= L+M-1 \\
X[i] = max(S[i] - S[i-L], X[i-1]) \text{ for } i > L \\
Y[i] = max(S[i] - S[i-M], Y[i-1]) \text{ for } i > M         \\

$$

**算法如下**<br/>
```python
class Solution:
    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
        for i in range(1, len(A)):
            A[i] += A[i-1]
        
        X = [0 for i in range(len(A))]
        Y = [0 for i in range(len(A))]
        ans = 0
        X[L-1] = A[L-1]
        Y[M-1] = A[M-1]
        for i in range(min(L, M), len(A)):
            if i >= L: X[i] = max(X[i-1], A[i]-A[i-L])
            if i >= M: Y[i] = max(Y[i-1], A[i]-A[i-M])
            if i >= L+M-1:
                ans = max(ans, X[i-M]+A[i]-A[i-M], Y[i-L]+A[i]-A[i-L])
        return ans
```

### 1031**改**. [两个非重叠子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-of-two-non-overlapping-subarrays/)

改动上一题（1031），上一题规定了子数组的长度必须等于给定长度，现在改为子数组长度必须小于等于给定长度，即子数组可以小于给定长度，且数组值可以为负数。


**分析**<br/><br/>
修改之后首先需要解决的是，求给定长度限制的最大子序和问题。


这道题目的难点是要同时求两个非重叠的子数组，而且规定了子数组的长度。首先需要求得 $A[0:j]$ 内，长度为 $L$ 的最大子序和（不一定要包括j），使用前缀和加DP解决。通过前缀和可以常数时间内获得 $\sum A[j-L, j]$ ，然后利用DP一直记录即可。在获取 $A[0:j]$ 内，长度为 $L$ 的最大子序和后，首先假设 $L$ 在前，$M$ 在后，则遍历所有的长度为 $L$ 的最大子序和以及长度为 $M$ 的子数组，即可获得全局最优解。然后反过来即可。

假设 $S$ 为前缀和数组，$X$ 为长度为 $L$ 的最大子序和，$y$ 为长度为 $M$ 的最大子序和。则
$$

ans = max(ans, X[i-M] + S[i] - S[i-M], Y[i-L] + S[i] - S[i-L]) \text{ for } i >= L+M-1 \\
X[i] = max(S[i] - S[i-L], X[i-1]) \text{ for } i > L \\
Y[i] = max(S[i] - S[i-M], Y[i-1]) \text{ for } i > M         \\

$$

