# 算法笔记
---
## 1. 数据结构
### 1.1 链表篇
#### 2. Add Two Numbers 

**题目** ```medium``` <br/>
> You are given two non-empty linked listsrepresenting two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br/>
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)<br/>
Output: 7 -> 0 -> 8

**分析**<br/><br/>
一道非常简单的题目。由于题目已经将输入逆序（个位最前，十位其次，。。。），故不需要使用递归算法或栈结构，直接迭代数据即可。
每次计算相同的位，当两数之和大于9时需要进位，迭代全部位数即可。
<br/><br/>**技巧**<br/><br/>
由于涉及到两个链表的操作，设置一个头结点是非常方便的，可以统一的对链表进行操作。<br/><br/>
[官方solution](https://leetcode.com/problems/add-two-numbers/solution/)<br/><br/>
**题解**<br/><br/>
```python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        dummy_head = ListNode(0)                        #哑的头结点
        cur_l1, cur_l2, cur_res = l1, l2, dummy_head
        carry = 0                                       #进位
        while cur_l1 is not None or cur_l2 is not None or carry != 0:
            x = cur_l1.val if cur_l1 else 0
            y = cur_l2.val if cur_l2 else 0
            sum_val = x + y + carry
            carry = sum_val / 10
            cur_res.next = ListNode(sum_val % 10)
            cur_res = cur_res.next
            if cur_l1 is not None:  cur_l1 = cur_l1.next
            if cur_l2 is not None:  cur_l2 = cur_l2.next
        return dummy_head.next
```

#### 445. Add Two Numbers II 
**题目** ```medium```  <br/> 
> 
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.<br/>
Example:<br/>
Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)<br/>
Output: 7 -> 8 -> 0 -> 7

**分析**<br/><br/>
与第二题唯一不同点在于这道题的链表顺序是逆序的，因此不能直接遍历。在这道题中，由于两链表长度不一定相同，使用递归方法不方便控制。可采用栈来进行处理，将两链表分别存储到两个栈中，再遍历栈顶处理。<br/><br/>
[官方solution](https://leetcode.com/problems/add-two-numbers-ii/discuss/)<br/><br/>
**题解**<br/><br/>
```python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        dummy_head = ListNode(0)                            #哑的头结点
        p_stack, q_stack = [], []                           #栈
        while l1 is not None:
            p_stack.append(l1.val)
            l1 = l1.next
        while l2 is not None:
            q_stack.append(l2.val)
            l2 = l2.next
        carry = 0
        while len(p_stack) or len(q_stack) or carry:
            x = p_stack[-1] if len(p_stack) else 0
            y = q_stack[-1] if len(q_stack) else 0
            sum_val = x + y + carry
            carry = sum_val // 10
            cur_node = ListNode(sum_val % 10)
            cur_node.next = dummy_head.next
            dummy_head.next = cur_node
            if len(p_stack): p_stack.pop() 
            if len(q_stack): q_stack.pop()
        return dummy_head.next
```

#### 61. Rotate List 

**题目** ```medium``` <br/>
> Given a list, rotate the list to the right by k places, where k is non-negative.<br/>
For example:<br/>
Given 1->2->3->4->5->NULL and k = 2,<br/>
return 4->5->1->2->3->NULL.

**分析**<br/><br/>
由于是链式存储，且移动操作不会导致两段内部的顺序打乱，因此只需要找到链表打断的位置。也就是找到新链表的最后一个节点，和第一个节点，重置它们的next指针即可。<br/><br/>
***算法如下***<br/><br/>
1. 计算链表长度 ```n```和真实移动距离```k % n```
2. 找到新链表最后一个节点，它的next即为新链表的第一个节点（**注意，这里的链表视作一个循环链表**）。
3. 重置二者指针。
```python
class Solution(object):
    def rotateRight(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        if head is None or head.next is None:
            return head
        original_last, new_last = head, head
        length = 1
        while original_last.next is not None:
            length += 1
            original_last = original_last.next
        for i in range(length - (k % length) - 1):
            new_last = new_last.next
        original_last.next = head   #do rotation
        new_head = new_last.next if new_last.next else head
        new_last.next = None
        return new_head
```
**性能**<br/><br/>
<img src="http://owdgmi7qq.bkt.clouddn.com/17-9-20/92599210.jpg" width="650">

#### 61. Reverse Nodes in k-Group

**题目** ```hard``` <br/>
> Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
You may not alter the values in the nodes, only nodes itself may be changed.
Only constant memory is allowed.<br/>
For example,<br/>
Given this linked list: 1->2->3->4->5<br/>
For k = 2, you should return: 2->1->4->3->5<br/>
For k = 3, you should return: 3->2->1->4->5

**分析**<br/><br/>
虽然被标为hard难度，但其实并不是太难。只是在多个不同区间上对链表进行reverse。需要注意的一点是，由于是链式存储，因此需要将各个reverse后的部分用指针连接起来。reverse可以采用迭代或递归两种方法求解。<br/><br/>
***算法如下***<br/><br/>
1. 对每个区段的链表进行reverse，这里应该写成一个函数，并返回最后一个（新first）元素，用于进行链表连接。
2. 对每个区段重复执行上述过程，并连接各个区段
```python
class Solution(object):
    def reverseKGroup(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        if head is None:
            return None
        new_head = self.sub_reverse_iteration(head,k)
        last_tail, sub_head = head, head.next
        while sub_head is not None:
            new_sub_head = self.sub_reverse_iteration(sub_head,k)
            last_tail.next = new_sub_head
            last_tail, sub_head = sub_head, sub_head.next
        return new_head
        
    def sub_reverse_iteration(self,head,k):
        """
        reverse given linked-list 'head' top-k elements, and return the new head node.
        iterative version
        """
        ## Calculate the length of given list.
        length = 0
        p = head
        while p is not None:
            p = p.next
            length += 1
        if length < k or length == 1:       # less than k or equal one, just return
            return head
        
        first, middle, last = head, head.next, head.next.next   # last may be None
        
        while middle is not None and k > 1:   #start reverse, After that, middle is the new head and head is the new tail
            middle.next = first
            first = middle
            middle = last
            last = last.next if last else None
            k -= 1
        
        head.next = middle      # for next function. just a temp pointer
        return first
```

**另一种逆转链表算法**<br/><br/>
前文所述的链表逆转算法如图。<br/>
<img src="http://owdgmi7qq.bkt.clouddn.com/17-9-20/40533795.jpg" width="650">
<br/><br/>每次将first和middle逆置位置，由于middle指针指向first，因此需要保存last使之不被丢失。每次整个方框向前移动一个，直到middle为None为止。
另一种方法如下<br/>
<img src="http://owdgmi7qq.bkt.clouddn.com/17-9-20/35571964.jpg" width="650">
<br/><br/>在前面插入一个dummy head用于平凡化头节点，依次遍历节点，并将该节点(temp)插入尾节点后面。充分利用了链表随意插入的特性。
```python
class Solution2(object):

    def reverseKGroup(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        if head is None or head.next is None or k < 2:
            return head

        dummy_head = ListNode(0)
        dummy_head.next = head

        head, tail, temp = dummy_head, dummy_head, None
        count = 0
        while tail is not None:
            for count in range(k):
                tail = tail.next
                if tail is None:
                    break
            else:
                original_head = head.next
                for count in range(k-1):
                    temp = head.next
                    head.next = temp.next
                    temp.next = tail.next
                    tail.next = temp
                
                tail = original_head
                head = original_head

        return dummy_head.next
```
#### 23. Merge k Sorted Lists
**题目** ```hard``` <br/>
```
Merge k sorted linked lists and return it as one sorted list. 
```
**分析**<br/><br/>
有多种方法可以解此题目，其中一种是依次比对k个链表的第一个元素的大小，并取其中最小的元素。
<br/><br/>**技巧**<br/><br/>
使用**优先队列**或**堆**来每次获取最小的元素<br/><br/>
***算法如下***<br/><br/>
```python
from Queue import PriorityQueue
class Solution(object):
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        dummy_head = ListNode(0)
        cur_head = dummy_head
        nodes_pq = PriorityQueue()
        for head in lists:
            if head: 
                nodes_pq.put((head.val, head))
        while nodes_pq.qsize() > 0:
            node = nodes_pq.get()[1]
            cur_head.next = node
            cur_head = cur_head.next
            node = node.next
            if node: nodes_pq.put((node.val,node))
        return dummy_head.next
```
[官方solution](https://leetcode.com/problems/merge-k-sorted-lists/solution/) 在官方Solution中列举了四种解法。包括采用数组排序，两两merge链表，以及分治法merge链表<br/><br/>

#### 总结
1. 构造dummy head是平凡化头节点的有力方式，可以较好地简化算法。
2. 链表的精髓即在于链式的存储，可以非常方便的更改结构
3. 逆置链表的一个有力方式是依次把元素插在尾节点后面。
4. 当需要按顺序取元素时，使用一个优先队列或者堆是一种好的方法
5. 当需要对K个任务执行相似的操作时，两两依次是一种方式，而分治法则格外适合优化这种情况。

       










