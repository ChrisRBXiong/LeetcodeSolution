# 动态规划篇
---


## 完全背包问题
完全背包问题是01背包问题的扩展，给定背包最大容量 $V$ ，给定一组 $N$ 个物品，物品的重量为 $w[1], w[2], ... w[N]$ ，物品的价值分别为 $v[1], v[2], ..., v[N]$ ，要求求可以放入背包的物品的最大价值总和。求解方式如下：两重遍历，遍历可选的物品，内层遍历总和价值。

```python
dp = [0 for i in range(V+1)]
for i in range(1, N+1): # 尝试放入第i个物品
    for j in range(1, V+1):     # 总价值为j
        dp[j] = max(dp[j], dp[j-w[i]]+v[i])              #dp[j]为不选当前这个物品，直接用上一轮的物品
return max(dp)
```

### 14.1. [剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/) ```medium```
<img src="img/14.1.png" width="">

**分析**<br/><br/>
该题可以看作一个完全背包问题。给定N，由于要求至少要有2段，可选的数字有1至N-1，将每个数字的重量看作1，则总容量为N，即要求找到一种数字组合使得总价值最大，且数字重量之和为N。我们可以可选数字的范围约简为1至math.ceil(N/2)，因为是两边是对称的。


**算法如下**<br/>
```python
import math
class Solution:
    def cuttingRope(self, n: int) -> int:
        dp = [1 for i in range(n+1)]
        for i in range(1, math.ceil(n/2)+1):
            for v in range(i, n+1):
                dp[v] = max(dp[v], dp[v-i]*i)
        return dp[-1]
```



## 路径动态规划


### .47 [礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/) ```medium```
<img src="img/.47.png" width="">

**分析**<br/><br/>
由于只能往右或下走，因此可以采用迭代法求解该动态规划，dp[i, j] = max(dp[i-1, j], dp[i, j-1]) + grid[i,j]


**算法如下**<br/>
```python
class Solution:
    def maxValue(self, grid: List[List[int]]) -> int:
        dp = [[0 for i in range(len(grid[0]))] for j in range(len(grid))]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                up = dp[i-1][j] if i > 0 else 0 
                left = dp[i][j-1] if j > 0 else 0 
                dp[i][j] = max(up, left) + grid[i][j]
        return dp[-1][-1]
```


### 62. [不同路径](https://leetcode-cn.com/problems/unique-paths/) ```medium```
<img src="img/62.png" width="">

**分析**<br/><br/>
这道题可以用排列组合也可以用动态规划，动态规划法，dp[x][y] = dp[x-1][y] + dp[x][y-1]，可以对空间复杂度进行优化，因为每一步仅与左边和右边相关，可设置dp长度为min(长,宽)。

**算法如下**<br/>
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        if m == 0 or n == 0:
            return 0
        if m == 1 and n == 1:
            return 1

        smaller = min(m, n)
        if m < n:
            smaller, larger = m, n 
        else:
            smaller, larger = n, m 
        
        dp = [0 for i in range(smaller)]
        dp[0] = 1

        for i in range(larger):
            for j in range(smaller):
                dp[j] += (dp[j-1] if j > 0 else 0)
        return dp[-1]
```


### 63. [不同路径II](https://leetcode-cn.com/problems/unique-paths-ii/) ```medium```
<img src="img/63.png" width="">

**分析**<br/><br/>
动态规划法，与上题区别在于，若存在障碍则dp[x][y] = 0。

**算法如下**<br/>
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if len(obstacleGrid) == 0 or len(obstacleGrid[0]) == 0: return 0
        nrow, ncol = len(obstacleGrid), len(obstacleGrid[0])

        if nrow < ncol:
            smaller, larger = nrow, ncol
            row_larger = False
        else:
            smaller, larger = ncol, nrow
            row_larger = True
        

        dp = [0 for i in range(smaller)]
        dp[0] = 1
        for i in range(larger):
            for j in range(smaller):
                if row_larger:
                    x, y = i, j
                else:
                    x, y = j, i
                if obstacleGrid[x][y] == 1: # obstacle
                    dp[j] = 0
                else:
                    dp[j] += (dp[j-1] if j > 0 else 0)
        return dp[-1]
```